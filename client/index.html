<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>r/place – tiny client</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            margin: 16px;
        }

        .row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        #status {
            font-size: 12px;
            opacity: 0.8;
        }

        canvas {
            image-rendering: pixelated;
            border: 1px solid #ddd;
            background: #fff;
            cursor: crosshair;
        }

        input[type="text"] {
            width: 340px;
            padding: 6px 8px;
        }

        button {
            padding: 6px 10px;
        }

        .small {
            font-size: 12px;
            opacity: 0.75;
        }
    </style>
</head>
<body>
<div class="row">
    <button id="connect">Connect</button>
    <button id="crash">Crash node</button>
    <label>Color <input id="color" type="color" value="#ff0000"/></label>
    <span id="status" class="small">disconnected</span>
</div>

<canvas id="board" width="64" height="64"></canvas>
<div class="small">Tip: Shift-click picks the color from the pixel under the cursor.</div>
<div id="log"></div>

<script>
    (() => {
        const userId = crypto.randomUUID();
        const connectBtn = document.getElementById('connect');
        const crashBtn = document.getElementById('crash');
        const colorInput = document.getElementById('color');
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d', {willReadFrequently: true});
        const statusEl = document.getElementById('status');
        const logEl = document.getElementById('log');
        const PING_INTERVAL = 5000;
        const RECONNECT_DELAY = 500;
        const PATIENCE = 3000;

        // visual scale (CSS-only) so pixels look big & crisp
        const SCALE = 8;
        canvas.style.width = (canvas.width * SCALE) + 'px';
        canvas.style.height = (canvas.height * SCALE) + 'px';

        let ws = null;
        let W = 64, H = 64;
        let isConnected = false;

        function setIsConnected(v) {
            if (v === isConnected) return;
            isConnected = v;
            setStatus(v ? 'connected' : 'disconnected');
            connectBtn.textContent = v ? 'Disconnect' : 'Connect';
        }

        function appendLog(text) {
            const p = document.createElement('div');
            p.textContent = text;
            logEl.appendChild(p);
            logEl.scrollTop = logEl.scrollHeight;
        }

        /**
         * Update status text
         * @param {string} text
         */
        function setStatus(text) {
            statusEl.textContent = text;
            appendLog(text);
        }


        /**
         * Send a pixel set request to the server
         * @param {number} x - x coordinate
         * @param {number} y - y coordinate
         * @param {string} color - hex string like "#ff0000"
         */
        async function setPixel(x, y, color) {
            if (!isConnected) connect().then()
            await fetch("/client/pixel", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    user_id: userId,
                    x: x,
                    y: y,
                    color: color
                })
            });
        }

        /**
         * Convert hex color string to integer
         * @param {string} hex - hex color string like "#ff0000"
         * @returns {number} - integer representation of the color
         */
        function fromHex(hex) {
            hex = hex.replace('#', '');
            return parseInt(hex, 16) >>> 0;
        }

        function setPixelLocal(x, y, color) {
            const img = ctx.getImageData(x, y, 1, 1);
            img.data[0] = (color >> 16) & 255;
            img.data[1] = (color >> 8) & 255;
            img.data[2] = color & 255;
            img.data[3] = 255;
            ctx.putImageData(img, x, y);
        }

        function pickPixel(x, y) {
            const data = ctx.getImageData(x, y, 1, 1);
            const [R, G, B] = data.map(v => v.toString(16).padStart(2, '0'))
            colorInput.value = `#${R}${G}${B}`;
        }

        /**
         * Get canvas pixel coordinates from mouse event
         * @param {MouseEvent} evt
         * @returns {[number, number]} - [x, y] coordinates
         */
        function canvasXY(evt) {
            const rect = canvas.getBoundingClientRect();
            const cx = Math.floor((evt.clientX - rect.left) / (rect.width / W));
            const cy = Math.floor((evt.clientY - rect.top) / (rect.height / H));
            return [Math.max(0, Math.min(W - 1, cx)), Math.max(0, Math.min(H - 1, cy))];
        }

        canvas.addEventListener('click', (evt) => {
            const [x, y] = canvasXY(evt);
            if (evt.shiftKey) pickPixel(x, y);
            else setPixel(x, y, colorInput.value);
        });

        function connect() {
            return new Promise((resolve) => {
                disconnect()
                ws = new WebSocket("/ws/");
                setStatus('connecting…');

                let timeout = undefined;

                function ping() {
                    ws.send(JSON.stringify({type: 'ping'}));
                    appendLog('ping ->');
                    timeout = setTimeout(disconnect, PATIENCE);
                }

                ws.onopen = () => {
                    setIsConnected(true)
                    timeout = setTimeout(ping, PING_INTERVAL);
                    resolve(ws)
                    ws.send(JSON.stringify({
                        type: 'connect',
                        content: {user_id: userId}
                    }))
                };

                crashBtn.addEventListener('click', () => {
                    console.log("crash node");
                    ws.send(JSON.stringify({
                        type: 'crash',
                    }))
                });

                ws.onclose = () => {
                    setIsConnected(false)
                    setStatus('disconnected');
                    clearTimeout(timeout);
                };

                ws.onerror = () => setStatus('error (see console)');

                ws.onmessage = (ev) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(ping, PING_INTERVAL);

                    let msg;
                    try {
                        msg = JSON.parse(ev.data);
                    } catch (e) {
                        setStatus(`error: invalid message, message=${ev.data}`);
                        return;
                    }

                    switch (msg.type) {
                        case 'error':
                            setStatus(`error: ${msg.message || '?'}`);
                            return;
                        case 'connected':
                            const canvasData = msg.content.canvas;
                            const {id: nodeId, role} = msg.content.node;
                            appendLog(`<- connected: node=${nodeId} (${role})`);
                            const img = new Image();
                            img.onload = () => ctx.drawImage(img, 0, 0)
                            img.src = "data:image/png;base64," + canvasData
                            return;
                        case 'pixel':
                            const {x, y, color, user_id} = msg.content;
                            appendLog(`<- pixel set: (${x}, ${y}) = ${color} by ${user_id}${user_id === userId ? ' (you)' : ''}`);
                            setPixelLocal(x, y, fromHex(color));
                            return;
                        case 'pong':
                            appendLog('<- pong');
                            return;
                        default:
                            setStatus(`error: unknown message type "${msg.type}"`);
                            return;
                    }
                }
            })

        }

        function disconnect(reconnect = false) {
            if (ws) {
                ws.close();
                ws = null;
            }
            setIsConnected(false);
            if (reconnect) setTimeout(connect, RECONNECT_DELAY);
        }

        connect()

        connectBtn.addEventListener('click', () => {
            if (isConnected) disconnect()
            else connect();

        });


    })();
</script>
</body>
</html>
